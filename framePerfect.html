<!DOCTYPE html>
<html lang="en">
<!-- A challenge to recreate frame perfect actions from speedruns
		Some famous default actions
		Custom actions via JSON input
		Custom Keyboard and gamepad support
	Vibe coded with Claude
	Created by cswert
	Last modified 24 Oct 2025-->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Frame Perfect</title>
<style>
	:root {
		--primary: #00ff88;
		--secondary: #667eea;
		--background: #1a1a2e;
		--background-secondary: #16213e;
		--text: #eee;
		--text-secondary: #aaa;
		--error: #ff4444;
		--warning: #ffd700;
		--success: #00ff88;
		--border: rgba(255, 255, 255, 0.05);
		--shadow: rgba(0, 0, 0, 0.3);
	}
	* {margin: 0; padding: 0; box-sizing: border-box;}
	body {
		font-family: 'Courier New', monospace;
		background: linear-gradient(135deg, var(--background) 0%, var(--background-secondary) 100%);
		color: var(--text);
		min-height: 100vh;
		display: flex;
		justify-content: center;
		align-items: center;
		padding: 20px;
	}
	.container {
		max-width: 900px;
		width: 100%;
		background: var(--border);
		border-radius: 15px;
		padding: 30px;
		box-shadow: 0 8px 32px var(--shadow);
		backdrop-filter: blur(10px);
	}
	h1 {
		text-align: center;
		color: var(--primary);
		margin-bottom: 10px;
		font-size: 2.5em;
		text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
	}
	.subtitle {text-align: center; color: var(--text-secondary); margin-bottom: 5px; font-size: 0.9em;}
	.setupSection {margin-bottom: 30px;}
	button {
		background: linear-gradient(135deg, var(--secondary) 0%, #764ba2 100%);
		color: white;
		border: none;
		padding: 12px 24px;
		border-radius: 8px;
		cursor: pointer;
		font-size: 1em;
		font-family: 'Courier New', monospace;
		transition: all 0.3s;
		box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
	}
	button:hover {transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);}
	button:active {transform: translateY(0);}
	button:disabled {background: #555; cursor: not-allowed; box-shadow: none;}
	.jsonInputArea {margin-bottom: 20px;}
	textarea {
		width: 100%;
		min-height: 120px;
		background: rgba(0, 0, 0, 0.3);
		border: 2px solid var(--secondary);
		border-radius: 8px;
		color: var(--text);
		padding: 15px;
		font-family: 'Courier New', monospace;
		font-size: 0.9em;
		resize: vertical;
	}
	textarea:focus {outline: none; border-color: var(--primary); box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);}
	.gameArea {display: none; text-align: center;}
	.gameArea.active {display: block;}
	.frameCounter { font-size: 2em; margin-bottom: 20px; color: var(--primary);text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);}
	.currentFrame {font-size: 1.2em; margin-bottom: 10px; color: var(--text-secondary);}
	.loopCounter {font-size: 1em; margin-bottom: 20px; color: var(--warning);}
	.requiredActions {
		margin: 30px 0;
		padding: 20px;
		background: rgba(0, 0, 0, 0.3);
		border-radius: 10px;
		min-height: 100px;
		display: flex;
		align-items: center;
		overflow: hidden;
		position: relative;
	}
	.requiredActions::before {
		content: '';
		position: absolute;
		left: 50%;
		top: 0;
		bottom: 0;
		width: 3px;
		background: rgba(255, 215, 0, 0.8);
		z-index: 10;
		box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
	}
	.actionTrack {
		display: flex;
		align-items: center;
		gap: 15px;
		transition: transform 0.1s linear;
	}
	.frameColumn {
		display: flex;
		flex-direction: column;
		gap: 10px;
		align-items: center;
		min-width: 100px;
		width: 100px;
		flex-shrink: 0;
	}
	.actionButton {
		padding: 15px 30px;
		background: rgba(255, 255, 255, 0.1);
		border: 3px solid var(--secondary);
		border-radius: 10px;
		font-size: 1.5em;
		color: var(--text);
		min-width: 80px;
		text-transform: uppercase;
		font-weight: bold;
		white-space: nowrap;
	}
	.actionButton.pressed {background: var(--success); border-color: var(--success); color: #000;}
	.actionButton.missed {background: var(--error); border-color: var(--error); color: #fff;}
	.statusMessage {font-size: 1.2em; margin-top: 20px; min-height: 30px;font-weight: bold;}
	.statusMessage.perfect {color: var(--success);}
	.statusMessage.miss {color: var(--error);}
	.progressBar {
		width: 100%;
		height: 10px;
		background: rgba(0, 0, 0, 0.3);
		border-radius: 5px;
		overflow: hidden;
		margin-top: 20px;
	}
	.progressFill {
		height: 100%;
		background: linear-gradient(90deg, var(--secondary) 0%, var(--primary) 100%);
		transition: width 0.1s linear;
	}
	.resultsSection {display: none; text-align: center; animation: fadeIn 0.5s;}
	.resultsSection.active {display: block;}
	@keyframes fadeIn {
		from { opacity: 0; transform: translateY(20px); }
		to { opacity: 1; transform: translateY(0); }
	}
	.resultsScore {
		font-size: 3em;
		margin: 30px 0;
		color: var(--primary);
		text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
	}
	.resultsDetails {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
		gap: 20px;
		margin: 30px 0;
	}
	.resultStat {background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 10px; border: 2px solid var(--secondary);}
	.resultStatValue {font-size: 2em; color: var(--primary);}
	.resultStatLabel {color: var(--text-secondary); font-size: 0.9em;}
	.errorMessage {
		background: rgba(255, 68, 68, 0.2);
		border: 2px solid var(--error);
		border-radius: 8px;
		padding: 15px;
		margin-top: 10px;
		color: var(--error);
		display: none;
	}
	.errorMessage.active {display: block;}
	.configModal {
		display: none;
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background: rgba(0, 0, 0, 0.8);
		z-index: 1000;
		justify-content: center;
		align-items: center;
	}
	.configModal.active {display: flex;}
	.configContent {
		background: linear-gradient(135deg, var(--background) 0%, var(--background-secondary) 100%);
		border: 2px solid var(--secondary);
		border-radius: 15px;
		padding: 30px;
		max-width: 700px;
		width: 90%;
		max-height: 85vh;
		overflow-y: auto;
		display: flex;
		flex-direction: column;
	}
	.configSection {flex: 1; overflow-y: auto; margin-bottom: 15px;}
	.configSection h3 {color: var(--primary); margin-bottom: 15px; font-size: 1.3em;}
	.configRow {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 8px 12px;
		margin-bottom: 6px;
		background: rgba(0, 0, 0, 0.3);
		border-radius: 5px;
		gap: 10px;
	}
	.configRow label {color: var(--text); font-size: 0.95em; flex: 1; min-width: 0;}
	.configRow button {padding: 6px 14px; font-size: 0.85em; min-width: 90px; flex-shrink: 0;}
	.configButtons {display: flex; gap: 10px; justify-content: center; margin-top: 20px;}
	.replayTimelineControls {margin-bottom: 8px; display: flex; align-items: center; gap: 10px;}
	#replayTrackContainer {
		overflow-x: auto;
		padding: 10px;
		background: rgba(0, 0, 0, 0.2);
		border-radius: 8px;
		position: relative;
		padding-left: 90px;
		z-index: 0;
	}
	#replayFrameMarkers {
		position: absolute;
		top: 0;
		left: 90px;
		bottom: 0;
		pointer-events: none;
		z-index: 1;
	}
	.replayRow {display: flex; align-items: center; margin-bottom: 4px; height: 28px; position: relative;}
	.replayRowLabel {
		width: 80px;
		font-size: 12px;
		font-weight: bold;
		color: var(--text-secondary);
		text-align: right;
		padding-right: 10px;
		flex-shrink: 0;
		position: fixed;
		left: 25px;
		z-index: 5;
	}
	.replayRowLabel.expected {color: var(--warning);}
	.replayTrack {position: relative; height: 100%; flex-grow: 1;}
	.replayFrameMarker {
		position: absolute;
		top: 0;
		width: 2px;
		height: 100%;
		background: #444;
	}
	#replayPlayhead {
		position: absolute;
		top: 0;
		bottom: 0;
		width: 3px;
		background: var(--warning);
		z-index: 100;
		box-shadow: 0 0 10px var(--warning);
		pointer-events: none;
	}
	.replayEvent {
		position: absolute;
		height: 20px;
		border-radius: 4px;
		border: 2px solid #000;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 10px;
		font-weight: bold;
		z-index: 2;
		top: 4px;
	}
	.replayEvent.expected {
		background: #222;
		color: var(--warning);
		border-color: var(--warning);
		box-shadow: 0 0 4px #ffd70044;
		width: 24px;
	}
	.replayEvent.hold {
		background: rgba(255, 255, 255, 0.2);
		border: 2px solid #666;
		border-left: none;
		border-right: none;
		border-radius: 0;
		min-width: 4px;
	}
	.replayEvent.hold.first {
		border-left: 2px solid #666;
		border-top-left-radius: 4px;
		border-bottom-left-radius: 4px;
		border-top-right-radius: 0;
		border-bottom-right-radius: 0;
	}
	.replayEvent.hold.last {
		border-right: 2px solid #666;
		border-top-right-radius: 4px;
		border-bottom-right-radius: 4px;
		border-top-left-radius: 0;
		border-bottom-left-radius: 0;
	}
	.replayEvent.hold.first.last {
		border-radius: 4px;
	}
	.replayEvent.hold.correct {
		background: rgba(0, 255, 136, 0.4);
		border-color: var(--success);
		box-shadow: 0 0 4px #00ff8844;
	}
	.replayEvent.hold.correct.first {
		border-left-color: var(--success);
	}
	.replayEvent.hold.correct.last {
		border-right-color: var(--success);
	}
	.replayEvent.hold.incorrect {
		background: rgba(255, 68, 68, 0.4);
		border-color: var(--error);
		box-shadow: 0 0 4px #ff444444;
	}
	.replayEvent.hold.incorrect.first {
		border-left-color: var(--error);
	}
	.replayEvent.hold.incorrect.last {
		border-right-color: var(--error);
	}
	input[type="range"] {vertical-align:middle; width:100px;}
</style>
<body>
	<div class="container">
		<h1>⚡ FRAME PERFECT ⚡</h1>
		<p class="subtitle">Master the art of frame-perfect inputs</p>
		<div class="setupSection" id="setupSection">
			<div class="jsonInputArea">
				<label for="jsonInput" style="display: block; margin-bottom: 10px; color: var(--primary);">JSON Input:</label>
				<textarea id="jsonInput" placeholder='{"fps": 30, "loops": 10, "actions": [["up"], ["a", "b"], []]}'></textarea>
				<div class="errorMessage" id="errorMessage"></div>
			</div>
			<div id="previewSection" style="display: none; margin-top: 20px;">
				<h3 style="color: var(--primary); margin-bottom: 10px; text-align: center; font-size: 1.1em;">Preview</h3>
				<div id="previewTrack" style="overflow-x: auto; padding: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; display: flex; gap: 15px; align-items: center;"></div>
			</div>
			<div style="display: flex; gap: 10px; justify-content: center;">
				<button id="startButton" onclick="startRun()">START CHALLENGE</button>
				<button id="configButton" onclick="toggleConfig()">CONFIGURE CONTROLS</button>
			</div>
			<div style="margin-top: 20px; text-align: center;">
				<label for="presetSelect" style="margin-bottom: 10px; color: var(--primary);">Select Preset:</label>
				<select id="presetSelect" onchange="jsonInput.value=JSON.stringify(defaults[this.value])">
					<option value="">-- Select a preset --</option>
				</select>
			</div>
		</div>
		<div class="configModal" id="configModal">
			<div class="configContent">
				<div class="configSection"><h3>Control Bindings</h3><div id="controlConfig"></div></div>
				<div class="configButtons">
					<button onclick="toggleConfig()">Close</button>
					<button onclick="localStorage.clear(); location.reload()">Reset</button>
				</div>
			</div>
		</div>
		<div class="gameArea" id="gameArea">
			<div class="frameCounter" id="frameCounter">Frame: 0</div>
			<div class="currentFrame" id="currentFrame">Current Frame: 1</div>
			<div class="loopCounter" id="loopCounter"></div>
			<div class="requiredActions" id="requiredActions"><p style="color: #aaa;">Get Ready...</p></div>
			<div class="statusMessage" id="statusMessage"></div>
			<div class="progressBar"><div class="progressFill" id="progressFill"></div></div>
			<div style="margin-top: 20px;"><button id="cancelButton" onclick="location.reload()">CANCEL</button></div>
		</div>
		<div class="resultsSection" id="resultsSection">
			<h2 style="color: var(--primary);">CHALLENGE COMPLETE!</h2>
			<div class="resultsScore" id="resultsScore">0%</div>
			<div class="resultsDetails">
				<div class="resultStat">
					<div class="resultStatValue" id="perfectInputs">0</div>
					<div class="resultStatLabel">Perfect</div>
				</div>
				<div class="resultStat">
					<div class="resultStatValue" id="missedInputs">0</div>
					<div class="resultStatLabel">Missed</div>
				</div>
				<div class="resultStat">
					<div class="resultStatValue" id="earlyInputs">0</div>
					<div class="resultStatLabel">Wrong</div>
				</div>
			</div>
			<div style="margin-top: 30px;"><button id="resetButton" onclick="location.reload()">TRY AGAIN</button></div>
		</div>
	</div>
</body>
<script>
	let gameState = {history:[]}, keyPress = {}, controller, deadZone = 0.5, historyInterval = null;
	let defaults = [
		{"name": "LoZ:WW Manual Super Swim", "fps": 30, "loops": 100, "actions": [["up"], ["down"]]},
		{"name": "LoZ:OoT Super Slide", "fps": 30, "loops": 0, "actions": [["down", "l1"], [2, "l1"], [2, "l1", "r1", "down"], 
			[3, "l1", "r1", "down", "a"], ["l1", "r1", "a"], [12 ,"l1"], [4, "l1", "r1"], ["l1", "r1"], [6, "l1", "r1", "a"], 
			[41, "l1", "r1"], [2, "l1", "r1", "a"], [2, "l1", "r1"], [2, "l1", "r1", "a"], [2, "l1", "r1"], [2, "l1", "r1", "a"], 
			[2, "l1", "r1"], [18, "l1", "r1", "a"], []]},
		{"name": "SMB1 Fast Accel", "fps": 60, "loops": 0, "actions": [["left", "b"], ["b"], ["right", "a", "b"]]}
	];
	defaults.forEach((preset, index) => {presetSelect.insertAdjacentHTML('beforeend', `<option value="${index}">${preset.name}</option>`);});
	
	function expandActions(items) {
		let actions = [];
		for (let item of items) {
			if (Array.isArray(item) && typeof item[0] === 'number') {
				for (let i = 0; i < item[0]; i++) {actions.push(item.slice(1));}
			}
			else actions.push(item);
		}
		return actions;
	}
	
	function updatePreview() {
		try {
			if (!jsonInput.value.trim()) {
				previewSection.style.display = 'none';
				errorMessage.classList.remove('active');
				return;
			}
			let parsed = JSON.parse(jsonInput.value);
			let actions = expandActions(parsed.actions);
			let totalFrames = actions.length * (parsed.loops || 1);

			let previewHTML = '';
			for (let i = 0; i < totalFrames; i++) {
				let frameActions = actions[i % actions.length];
				previewHTML += `<div class="frameColumn"><div style="font-size: 0.7em; 
					color: var(--text-secondary); margin-bottom: 5px;">${i+1}</div>`;
				if (frameActions.length === 0) previewHTML += '<div class="actionButton">—</div>';
				else {
					frameActions.forEach(action => {
						previewHTML += '<div class="actionButton">' + action.toUpperCase() + '</div>';
					});
				}
				previewHTML += '</div>';
			}
			previewTrack.innerHTML = previewHTML;
			previewSection.style.display = 'block';
			errorMessage.classList.remove('active');
		} catch (e) {
			previewSection.style.display = 'none';
			errorMessage.textContent = 'Invalid JSON: ' + e.message;
			errorMessage.classList.add('active');
		}
	}
	
	jsonInput.addEventListener('input', updatePreview);
	presetSelect.addEventListener('change', () => {setTimeout(updatePreview, 0);});
	
	function startRun() {
		if (!jsonInput.value.trim()) {alert("Please enter JSON input."); return;}
		let parsed = JSON.parse(jsonInput.value);
		gameState.fps = parsed.fps || 30;
		gameState.loops = parsed.loops || 0;
		gameState.actions = expandActions(parsed.actions);
		gameState.totalFrames = gameState.actions.length * (gameState.loops || 1);
		gameState.currentFrame = 0;
		gameState.stats = {perfect: 0, missed: 0, wrong: 0};
		gameState.history = [];
		for (let key in keyPress) {delete keyPress[key];}
		setupSection.style.display = 'none';
		gameArea.classList.add('active');
		resultsSection.classList.remove('active');
		updatePlayingArea();
		if (historyInterval) clearInterval(historyInterval);
		let lastSnapshot = JSON.stringify(keyPress);
		historyInterval = setInterval(() => {
			let nowSnapshot = JSON.stringify(keyPress);
			if (nowSnapshot !== lastSnapshot) {
				lastSnapshot = nowSnapshot;
				if (!gameState.history.length || gameState.history.at(-1)[1] != Date.now()) {
					gameState.history.push([{...keyPress}, Date.now()]);
				}
				if (gameState.currentFrame == 0) gameLoop();
			}
		}, 1);
	}

	window.addEventListener("keydown", function(e) {keyPress[e.key.toLowerCase()] = true;});
	window.addEventListener("keyup", function(e) {keyPress[e.key.toLowerCase()] = false;});
	window.addEventListener('mousedown', function(e) {keyPress["mouse" + e.button] = true;});
	window.addEventListener('mouseup', function(e) {keyPress["mouse" + e.button] = false;});
	window.addEventListener('touchstart', () => {keyPress["touch"] = true;});
	window.addEventListener('touchend', () => {keyPress["touch"] = false;});
	window.addEventListener("gamepadconnected", () => {
		controller = setInterval(() => {
			let gamepads = navigator.getGamepads();
			for (let gamepad of gamepads) {
				if (!gamepad) continue;
				gamepad.buttons.forEach((button, index) => {
					if (keyPress["gp" + index] !== button.pressed) keyPress["gp" + index] = button.pressed;
				});
				gamepad.axes.forEach((axis, index) => {
					if (axis < -deadZone) keyPress["gpa" + index + "n"] = true;
					else if (axis > deadZone) keyPress["gpa" + index + "p"] = true;
					else if (axis > -deadZone) keyPress["gpa" + index + "n"] = false;
					else if (axis < deadZone) keyPress["gpa" + index + "p"] = false;
				});
			}
		}, 16)
	});
	window.addEventListener("gamepaddisconnected", () => {clearInterval(controller);});

	function getMappedActions() {
		let pressed = Object.keys(keyPress).filter(k => keyPress[k]);
		let mapped = [];
		for (let action in remap) {
			if (remap[action].some(key => pressed.some(p => p.toLowerCase() === key.toLowerCase()))) {
				mapped.push(action);
			}
		}
		return mapped;
	}

	function updatePlayingArea() {
		let actionIndex = gameState.currentFrame % gameState.actions.length;
		frameCounter.textContent = `Frame: ${gameState.currentFrame + 1}`;
		currentFrame.textContent = `Action Frame: ${actionIndex + 1}/${gameState.actions.length}`;
		loopCounter.textContent = gameState.loops > 0 ? `Loop: ${Math.floor(gameState.currentFrame / gameState.actions.length) + 1}/${gameState.loops}` : '';
		progressFill.style.width = ((gameState.currentFrame / gameState.totalFrames) * 100) + '%';
		
		let columnWidth = 115;
		if (gameState.currentFrame === 0) {
			let temp = '<div class="actionTrack" id="actionTrack">';
			for (let i = 0; i < gameState.totalFrames; i++) {
				let frameActions = gameState.actions[i % gameState.actions.length];
				temp += `<div class="frameColumn" data-frame="${i}">`;
				if (frameActions.length === 0) {
					temp += '<div class="actionButton">—</div>';
				} else {
					for (let action of frameActions) {
						temp += `<div class="actionButton" data-action="${action}">${action.toUpperCase()}</div>`;
					}
				}
				temp += '</div>';
			}
			temp += '</div>';
			requiredActions.innerHTML = temp;
			actionTrack.style.transform = `translateX(${requiredActions.offsetWidth / 2 - 57.5}px)`;
		} 
		else {
			actionTrack.style.transform = `translateX(${requiredActions.offsetWidth / 2 - 57.5 - ((gameState.currentFrame - 1) * columnWidth)}px)`;
			let currentColumn = actionTrack.children[gameState.currentFrame - 1];
			if (currentColumn) {
				let mappedActions = getMappedActions();
				let required = gameState.actions[(gameState.currentFrame - 1) % gameState.actions.length];
				let mappedSet = new Set(mappedActions);
				let allMatch = required.length === mappedActions.length && required.every(action => mappedSet.has(action));
				for (let btn of currentColumn.children) {
					btn.classList.add(allMatch ? 'pressed' : 'missed');
				}
				statusMessage.textContent = allMatch ? 'PERFECT!' : 'Missed!';
				statusMessage.className = 'statusMessage ' + (allMatch ? 'perfect' : 'miss');
			}
		}
	}

	function gameLoop() {
		if (gameState.currentFrame === 0) {
			setupSection.style.display = 'none';
			gameArea.classList.add('active');
			resultsSection.classList.remove('active');
		}
		gameState.currentFrame++;
		let mappedActions = getMappedActions();
		let required = gameState.actions[gameState.currentFrame] || [];
		let mappedSet = new Set(mappedActions);
		let allMatch = required.length === mappedActions.length && required.every(action => mappedSet.has(action));
		gameState.stats[allMatch ? 'perfect' : mappedActions.length === 0 ? 'missed' : 'wrong']++;
		updatePlayingArea();
		if (gameState.currentFrame < gameState.totalFrames) setTimeout(gameLoop, 1000/gameState.fps);
		else endRun();
	}

	function endRun() {
		gameArea.classList.remove('active');
		resultsSection.classList.add('active');
		resultsScore.textContent = Math.round((gameState.stats.perfect / gameState.totalFrames) * 100) + '%';
		perfectInputs.textContent = gameState.stats.perfect;
		missedInputs.textContent = gameState.stats.missed;
		earlyInputs.textContent = gameState.stats.wrong;
		let replayHTML = `<h3 style="color:var(--primary); margin-top:30px;">Input Replay</h3>`;
		replayHTML += `<div class="replayTimelineControls">
			<button id='replayPlayPauseBtn' style="padding:4px 12px; font-size:1em;">▶️ Play</button>
			<span style='margin-left:20px;'>Zoom: 
			<input id='replayZoomSlider' type='range' min='1' max='100' step='1' value='1.0'>
			<span id='replayZoomVal'>1.0x</span></span>
			<span style='margin-left:20px;'>Speed: 
			<input id='replaySpeedSlider' type='range' min='0.01' max='2' step='0.01' value='1.0'>
			<span id='replaySpeedVal'>1.0x</span></span>
		</div>`;
		let frameInterval = 1000 / gameState.fps;
		let startTime = gameState.history.length > 0 ? gameState.history[0][1] : 0;
		let endTime = startTime + gameState.totalFrames * frameInterval;
		let events = [];
		let prevState = {};
		for (let [snapshot, t] of gameState.history) {
			if (t > endTime) break;
			for (let k in snapshot) {
				if (snapshot[k] !== prevState[k]) {
					let label = k.toUpperCase();
					for (let action in remap) {
						if (remap[action].some(key => key.toLowerCase() === k.toLowerCase())) {
							label = action.toUpperCase();
							break;
						}
					}
					events.push({input: label, type: snapshot[k] ? 'pressed' : 'released', time: t});
				}
			}
			for (let k in prevState) {
				if (!(k in snapshot) && prevState[k]) {
					let label = k.toUpperCase();
					for (let action in remap) {
						if (remap[action].some(key => key.toLowerCase() === k.toLowerCase())) {
							label = action.toUpperCase();
							break;
						}
					}
					events.push({input: label, type: 'released', time: t});
				}
			}
			prevState = {...snapshot};
		}
		let allInputs = new Set();
		for (let e of events) {allInputs.add(e.input);}
		replayHTML += `<div id="replayTrackContainer"><div id="replayFrameMarkers">`;
		for (let i = 0; i < gameState.totalFrames; i++) {
			let frameTime = startTime + i * frameInterval;
			replayHTML += `<div class="replayFrameMarker" data-data-frame="${i + 1}" data-data-time="${frameTime}"></div>`;
		}
		replayHTML += `</div><div class="replayRow"> 
			<div class="replayRowLabel expected">EXPECTED</div> <div class="replayTrack" id="expectedTrack">`;
		for (let i = 0; i < gameState.totalFrames; i++) {
			let frameTime = startTime + i * frameInterval;
			let expectedActions = gameState.actions[i % gameState.actions.length] || [];
			if (expectedActions.length > 0) {
				let label = expectedActions.map(a => a.toUpperCase()).join(',');
				replayHTML += `<div class="replayEvent expected" data-data-time="${frameTime}" 
					title="Frame ${i+1}: ${label}">${label}</div>`;
			}
		}
		replayHTML += `</div></div>`;
		for (let input of [...allInputs].sort()) {
			replayHTML += `<div class="replayRow"><div class="replayRowLabel">${input}</div>`;
			replayHTML += `<div class="replayTrack" data-input="${input}">`;
			let inputEvents = events.filter(e => e.input === input);
			let holds = [];
			for (let i = 0; i < inputEvents.length; i++) {
				if (inputEvents[i].type === 'pressed') {
					let pressTime = inputEvents[i].time;
					let releaseTime = endTime;
					for (let j = i + 1; j < inputEvents.length; j++) {
						if (inputEvents[j].type === 'released') {
							releaseTime = inputEvents[j].time;
							break;
						}
					}
					let pressFrame = Math.floor((pressTime - startTime) / frameInterval);
					let releaseFrame = Math.floor((releaseTime - startTime) / frameInterval);
					let mappedAction = input.toLowerCase();
					for (let action in remap) {
						if (remap[action].some(key => key.toLowerCase() === input.toLowerCase())) {
							mappedAction = action;
							break;
						}
					}
					let segments = [];
					let pressOffset = ((pressTime - startTime) % frameInterval) / frameInterval;
					let releaseOffset = ((releaseTime - startTime) % frameInterval) / frameInterval;
					for (let f = pressFrame; f <= releaseFrame && f < gameState.totalFrames; f++) {
						let expectedActions = gameState.actions[f % gameState.actions.length] || [];
						let isCorrect = expectedActions.includes(mappedAction);
						segments.push({pressTime: Math.max(pressTime, startTime + f * frameInterval), 
							releaseTime: Math.min(releaseTime, startTime + (f + 1) * frameInterval), frame: f + 1,
							isCorrect, pressFrame, releaseFrame, pressOffset, releaseOffset});
					}
					for (let idx = 0; idx < segments.length; idx++) {
						segments[idx].isFirst = (idx === 0);
						segments[idx].isLast = (idx === segments.length - 1);
					}
					holds.push(...segments);
				}
			}
			for (let hold of holds) {
				let pressStr = `f${hold.pressFrame + 1}+${(hold.pressOffset * 100).toFixed(1)}%`;
				let releaseStr = `f${hold.releaseFrame + 1}+${(hold.releaseOffset * 100).toFixed(1)}%`;
				replayHTML += `<div class="replayEvent hold ${hold.isCorrect ? 'correct' : 'incorrect'}
					${hold.isFirst ? ' first' : ''} ${hold.isLast ? ' last' : ''}" 
					data-data-time="${hold.pressTime}" data-data-release="${hold.releaseTime}" 
					title="${input} pressed ${pressStr} → released ${releaseStr} 
					(frame ${hold.frame}: ${hold.isCorrect ? 'Correct' : 'Incorrect'})"></div>`;
			}
			replayHTML += `</div></div>`;
		}
		replayHTML += `<div id="replayPlayhead" style="display:none;"></div></div>`;
		resultsSection.insertAdjacentHTML('beforeend', replayHTML);
		let playing = false, playSpeed = 1.0, zoom = 1.0, animationId = null;
		let pixelsPerMs = (replayTrackContainer.offsetWidth - 100) / (endTime - startTime);
		function updateZoom(newZoom) {
			zoom = newZoom;
			let trackWidth = (endTime - startTime) * pixelsPerMs * zoom;
			replayFrameMarkers.style.width = trackWidth + 'px';
			for (let track of document.querySelectorAll('.replayTrack')) {
				track.style.width = trackWidth + 'px';
			}
			for (let marker of replayFrameMarkers.children) {
				marker.style.left = ((parseFloat(marker.dataset.dataTime) - startTime) * pixelsPerMs * zoom) + 'px';
			}
			for (let event of document.querySelectorAll('.replayEvent')) {
				let pos = (parseFloat(event.dataset.dataTime) - startTime) * pixelsPerMs * zoom;
				if (event.classList.contains('hold')) {
					let releaseTime = parseFloat(event.dataset.dataRelease);
					let pressTime = parseFloat(event.dataset.dataTime);
					event.style.left = pos + 'px';
					event.style.width = Math.max(4, (releaseTime - pressTime) * pixelsPerMs * zoom) + 'px';
				} else {
					event.style.left = (pos - 12) + 'px';
				}
			}
		}
		replayZoomSlider.addEventListener('input', function() {
			updateZoom(parseFloat(this.value));
			replayZoomVal.textContent = parseFloat(this.value) + 'x';
		});
		replaySpeedSlider.addEventListener('input', function() {
			playSpeed = parseFloat(this.value);
			replaySpeedVal.textContent = playSpeed.toFixed(2) + 'x';
		});
		updateZoom(1.0);
		function playReplay() {
			if (playing) return;
			playing = true;
			replayPlayPauseBtn.textContent = '⏸️ Pause';
			replayPlayhead.style.display = 'block';
			let startPlayTime = performance.now();
			function smoothStep(currentTime) {
				if (!playing) {cancelAnimationFrame(animationId); return;}
				let currentFrame = (((currentTime - startPlayTime) * playSpeed) / 1000) * gameState.fps;
				if (currentFrame >= gameState.totalFrames) {
					playing = false;
					replayPlayPauseBtn.textContent = '▶️ Play';
					replayPlayhead.style.display = 'none';
					cancelAnimationFrame(animationId);
					return;
				}
				let playheadPos = ((startTime + (currentFrame * frameInterval)) - startTime) * pixelsPerMs * zoom;
				replayPlayhead.style.left = playheadPos + 'px';
				replayTrackContainer.scrollLeft = Math.max(0, playheadPos - replayTrackContainer.offsetWidth / 2);
				animationId = requestAnimationFrame(smoothStep);
			}
			animationId = requestAnimationFrame(smoothStep);
		}
		
		function pauseReplay() {
			playing = false;
			replayPlayPauseBtn.textContent = '▶️ Play';
			replayPlayhead.style.display = 'none';
		}
		
		replayPlayPauseBtn.onclick = function() {
			if (playing) pauseReplay();
			else playReplay();
		};
		
		replayTrackContainer.addEventListener('wheel', function(e) {
			e.preventDefault();
			let oldZoom = zoom;
			zoom = Math.max(0.1, Math.min(100, zoom * (1 - e.deltaY * 0.001)));
			replayZoomSlider.value = zoom;
			replayZoomVal.textContent = zoom.toFixed(1) + 'x';
			updateZoom(zoom);
			let mouseX = e.clientX - replayTrackContainer.getBoundingClientRect().left;
			replayTrackContainer.scrollLeft = replayTrackContainer.scrollLeft * (zoom / oldZoom) + mouseX * (zoom / oldZoom - 1);
		}, {passive: false});
		
		let isDragging = false, dragStartX, scrollStartX;
		replayTrackContainer.addEventListener('mousedown', function(e) {
			isDragging = true;
			dragStartX = e.clientX;
			scrollStartX = replayTrackContainer.scrollLeft;
			replayTrackContainer.style.cursor = 'grabbing';
		});
		window.addEventListener('mousemove', function(e) {
			if (!isDragging) return;
			replayTrackContainer.scrollLeft = scrollStartX - (e.clientX - dragStartX);
		});
		window.addEventListener('mouseup', function() {
			if (!isDragging) return;
			isDragging = false;
			replayTrackContainer.style.cursor = 'grab';
		});
	}

	let remap = localStorage.getItem('framePerfectRemap') ? JSON.parse(localStorage.getItem('framePerfectRemap')) : {
		up: ['w', 'gpa1n'], down: ['s', 'gpa1p'], left: ['a', 'gpa0n'], right: ['d', 'gpa0p'],
		Dup: ['arrowup', 'gp12'], Ddown: ['arrowdown', 'gp13'], Dleft: ['arrowleft', 'gp14'], Dright: ['arrowright', 'gp15'],
		Lup: ['8'], Ldown: ['2'], Lleft: ['4'], Lright: ['6'],
		a: ['space', 'j', 'gp0'], b: ['k', 'gp1'], x: ['l', 'gp2'], y: ['i', 'gp3'],
		l1: ['q', 'gp4'], r1: ['e', 'gp5'], l2: ['u', 'gp6'], r2: ['o', 'gp7'], r3: ['r'], l3: ['5'],
		start: ['enter', 'gp9'], select: ['tab', 'gp8']
	};

	function toggleConfig() {
		if (!configModal.classList.contains('active')) {
			controlConfig.innerHTML = '';
			for (let action in remap) {
				let displayKeys = remap[action].map(k => k === ' ' ? 'SPACE' : k.toUpperCase()).join(', ');
				controlConfig.innerHTML += `<div class="configRow"><label>${action.toUpperCase()} → ${displayKeys}
					</label><button onclick="remapKey('${action}')">Add Input</button></div>`;
			}
		}
		configModal.classList.toggle('active');
	}

	window.toggleButtons = function(enabled) {
		for (let child of controlConfig.children) child.children[1].disabled = !enabled;
	};
	window.finishRemap = function(action, newKey) {
		for (let act in remap) {
			remap[act] = remap[act].filter(k => k.toLowerCase() !== newKey.toLowerCase());
		}
		if (!remap[action].some(k => k.toLowerCase() === newKey.toLowerCase())) remap[action].push(newKey.toLowerCase());
		localStorage.setItem('framePerfectRemap', JSON.stringify(remap));
		toggleButtons(true);
		configModal.classList.remove('active');
		toggleConfig();
	};
	window.checkGamepadRemap = function() {
		for (let k in keyPress) {
			if (keyPress[k] && k.startsWith('gp')) {
				clearInterval(gameState.remapInterval);
				finishRemap(gameState.remapAction, k);
				return;
			}
		}
	};
	window.handleKeyRemap = function(e) {
		e.preventDefault();
		window.removeEventListener('keydown', window.handleKeyRemap);
		window.removeEventListener('mousedown', window.handleMouseRemap);
		finishRemap(gameState.remapAction, e.key.toLowerCase());
	};
	window.handleMouseRemap = function(e) {
		e.preventDefault();
		window.removeEventListener('keydown', window.handleKeyRemap);
		window.removeEventListener('mousedown', window.handleMouseRemap);
		finishRemap(gameState.remapAction, "mouse" + e.button);
	};
	window.remapKey = function(action) {
		toggleButtons(false);
		gameState.remapAction = action;
		gameState.remapInterval = setInterval(checkGamepadRemap, 50);
		window.addEventListener('keydown', window.handleKeyRemap);
		window.addEventListener('mousedown', window.handleMouseRemap);
	};
</script>
</html>