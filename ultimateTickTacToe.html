<!DOCTYPE html>
<title>Ultimate Tic-Tac-Toe</title>
<!-- Tic-Tac-Toe within Tic-Tac-Toe
	Players take turns playing on a 3x3 grid of 3x3 grids
		Easy CPU: Random moves
		Medium CPU: Mix of random and strategic moves
		Hard CPU: Minimax algorithm
	Vibe coded with ChatGPT
	Created by cswert
	Last modified 9 Oct 2025-->
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
	font-family: 'Arial', sans-serif;
	background-color: #1a1a1a;
	color: #ffffff;
	display: flex;
	justify-content: center;
	align-items: center;
	height: 100vh;
	margin: 0;
	overflow: hidden;
}
h1 {
	font-size: 2.5rem;
	margin-bottom: 1rem;
}
.board {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	gap: 10px;
	margin-bottom: 1rem;
}
.sub-board {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	gap: 2px;
	background-color: #333;
	padding: 5px;
	border-radius: 5px;
	position: relative;
}
.cell {
	width: 40px;
	height: 40px;
	background-color: #4a4a4a;
	display: flex;
	justify-content: center;
	align-items: center;
	font-size: 1.5rem;
	cursor: pointer;
	transition: background-color 0.3s;
}
.cell:hover {
	background-color: #555;
}
.winner {
	position: absolute;
	background-color: rgba(0, 0, 0, 0.8);
	color: #fff;
	font-size: 2rem;
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100%;
	height: 100%;
	top: 0;
	left: 0;
}
.controls {
	display: flex;
	justify-content: center;
	gap: 10px;
	margin-top: 1rem;
}
button, select {
	padding: 0.5rem 1rem;
	font-size: 1rem;
	background-color: #4a4a4a;
	color: #ffffff;
	border: none;
	border-radius: 5px;
	cursor: pointer;
	transition: background-color 0.3s;
}
button:hover, select:hover {
	background-color: #555;
}
.active-board {
	box-shadow: 0 0 10px 5px #ffff00;
}
</style>
<body>
	<div style="text-align: center;">
	<h1>Ultimate Tic-Tac-Toe</h1>
	<div id="game" class="board"></div>
	<div class="controls">
		<button onclick="resetGame()">Reset</button>
		<select id="opponent" onchange="resetGame()">
		<option>Human</option>
		<option>Easy CPU</option>
		<option>Medium CPU</option>
		<option>Hard CPU</option>
		</select>
	</div>
	</div>
</body>

<script>
	let gameArr = Array(10).fill().map(() => Array(10).fill(null));
	let player = 'X';
	let currentBoard = 0;
	let gameOver = false;

	function createBoard() {
		const game = document.getElementById('game');
		game.innerHTML = '';
		for (let i = 1; i <= 9; i++) {
		const subBoard = document.createElement('div');
		subBoard.className = 'sub-board';
		subBoard.id = `board-${i}`;
		for (let j = 1; j <= 9; j++) {
			const cell = document.createElement('div');
			cell.className = 'cell';
			cell.id = `${i}-${j}`;
			cell.onclick = () => makeMove(i, j);
			subBoard.appendChild(cell);
		}
		game.appendChild(subBoard);
		}
		updateActiveBoard();
	}

	function resetGame() {
		gameArr = Array(10).fill().map(() => Array(10).fill(null));
		player = 'X';
		currentBoard = 0;
		gameOver = false;
		createBoard();
	}

	function makeMove(board, cell) {
		if (gameOver || (currentBoard !== 0 && currentBoard !== board) || gameArr[board][cell] !== null || typeof gameArr[board] === 'string') return;

		gameArr[board][cell] = player;
		document.getElementById(`${board}-${cell}`).textContent = player;

		if (checkWin(gameArr[board])) {
		gameArr[board] = player;
		document.getElementById(`board-${board}`).innerHTML += `<div class="winner">${player}</div>`;
		} else if (checkDraw(gameArr[board])) {
		gameArr[board] = 'D';
		document.getElementById(`board-${board}`).innerHTML += '<div class="winner">Draw</div>';
		}
		
		if (checkGameWin(gameArr)) {
		document.getElementById('game').innerHTML += `<div class="winner">Player ${player} wins the game!</div>`;
		gameOver = true;
		return;
		} else if (checkGameDraw(gameArr)) {
		document.getElementById('game').innerHTML += '<div class="winner">The game is a draw!</div>';
		gameOver = true;
		return;
		}

		// Switch the player turn
		player = player === 'X' ? 'O' : 'X';
		currentBoard = typeof gameArr[cell] === 'object' ? cell : 0;
		updateActiveBoard();

		// Trigger CPU move if it's the CPU's turn
		if (player === 'O' && !gameOver) {
		const opponent = document.getElementById('opponent').value;
		if (opponent !== 'Human') {
			setTimeout(() => {
			// Ensure the CPU move gets triggered here
			cpuMove(opponent);
			}, 500);
		}
		}
	}

	function updateActiveBoard() {
		document.querySelectorAll('.sub-board').forEach(board => board.classList.remove('active-board'));
		if (currentBoard !== 0 && typeof gameArr[currentBoard] === 'object') {
		document.getElementById(`board-${currentBoard}`).classList.add('active-board');
		} else if (currentBoard === 0) {
		document.querySelectorAll('.sub-board').forEach(board => {
			if (typeof gameArr[parseInt(board.id.split('-')[1])] === 'object') {
			board.classList.add('active-board');
			}
		});
		}
	}

	function checkWin(board) {
		const lines = [
		[1, 2, 3], [4, 5, 6], [7, 8, 9],
		[1, 4, 7], [2, 5, 8], [3, 6, 9],
		[1, 5, 9], [3, 5, 7]
		];
		return lines.some(line => line.every(cell => board[cell] === player));
	}

	function checkDraw(board) {
		return board.slice(1).every(cell => cell !== null);
	}

	function checkGameWin(game) {
		const lines = [
		[1, 2, 3], [4, 5, 6], [7, 8, 9],
		[1, 4, 7], [2, 5, 8], [3, 6, 9],
		[1, 5, 9], [3, 5, 7]
		];
		return lines.some(line => line.every(cell => game[cell] === player));
	}

	function checkGameDraw(game) {
		return game.slice(1).every(board => typeof board !== 'object');
	}

	function cpuMove(difficulty) {
		let move;

		switch (difficulty) {
		case 'Easy CPU':
			move = easyMove();
			break;
		case 'Medium CPU':
			move = mediumMove();
			break;
		case 'Hard CPU':
			move = hardMove();
			break;
		}

		// If a move is returned, the CPU should make the move
		if (move && !gameOver) {
		makeMove(move.board, move.cell); // CPU executes the move
		}
	}


	function getAvailableBoards() {
		if (currentBoard !== 0 && typeof gameArr[currentBoard] === 'object') {
		return [currentBoard];
		}
		return [1, 2, 3, 4, 5, 6, 7, 8, 9].filter(b => typeof gameArr[b] === 'object');
	}

	function getAvailableCells(board) {
		// Cells are indexed from 1 to 9, so skip index 0
		return gameArr[board].reduce((acc, cell, index) => {
		if (index !== 0 && cell === null) acc.push(index); // Skip cell 0
		return acc;
		}, []);
	}

	function easyMove() {
		const availableBoards = getAvailableBoards();
		const board = availableBoards[Math.floor(Math.random() * availableBoards.length)];
		const availableCells = getAvailableCells(board);
		const cell = availableCells[Math.floor(Math.random() * availableCells.length)];
		return { board, cell };
	}

	function mediumMove() {
		return Math.random() < 0.5 ? hardMove() : easyMove();
	}

	function hardMove() {
		const availableBoards = getAvailableBoards();
		let bestScore = -Infinity;
		let bestMove;

		for (const board of availableBoards) {
		const availableCells = getAvailableCells(board);
		for (const cell of availableCells) {
			gameArr[board][cell] = 'O';
			const score = minimax(gameArr, 0, false, board, cell, -Infinity, Infinity);
			gameArr[board][cell] = null;
			if (score > bestScore) {
			bestScore = score;
			bestMove = { board, cell };
			}
		}
		}
		return bestMove;
	}

	function minimax(game, depth, isMaximizing, lastBoard, lastCell, alpha, beta) {
		if (checkGameWin(game)) {
		return isMaximizing ? -10 + depth : 10 - depth;
		}
		if (checkGameDraw(game) || depth > 7) { // Increase depth limit to 7
		return 0;
		}

		const availableBoards = typeof game[lastCell] === 'object' ? [lastCell] : 
		[1, 2, 3, 4, 5, 6, 7, 8, 9].filter(b => typeof game[b] === 'object');

		if (isMaximizing) {
		let maxScore = -Infinity;
		for (const board of availableBoards) {
			const availableCells = getAvailableCells(board);
			for (const cell of availableCells) {
			game[board][cell] = 'O';
			const score = minimax(game, depth + 1, false, board, cell, alpha, beta);
			game[board][cell] = null;
			maxScore = Math.max(score, maxScore);
			alpha = Math.max(alpha, score);
			if (beta <= alpha) break; // Alpha-beta pruning
			}
			if (beta <= alpha) break;
		}
		return maxScore;
		} else {
		let minScore = Infinity;
		for (const board of availableBoards) {
			const availableCells = getAvailableCells(board);
			for (const cell of availableCells) {
			game[board][cell] = 'X';
			const score = minimax(game, depth + 1, true, board, cell, alpha, beta);
			game[board][cell] = null;
			minScore = Math.min(score, minScore);
			beta = Math.min(beta, score);
			if (beta <= alpha) break; // Alpha-beta pruning
			}
			if (beta <= alpha) break;
		}
		return minScore;
		}
	}

window.onload = resetGame;
</script>
</html>