<!DOCTYPE html>
<title>Ultimate Tic-Tac-Toe</title>
<!-- Tic-Tac-Toe within Tic-Tac-Toe
	Players take turns playing on a 3x3 grid of 3x3 grids
	Alternate modes of Limited and Sudoku
		Easy CPU: Random moves
		Medium CPU: Mix of random and strategic moves
		Hard CPU: Minimax algorithm
		Impossible CPU: Minimax with optimizations
	Vibe coded with ChatGPT, and Claude
	Created by cswert
	Last modified 11 Oct 2025-->
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
	body {
		font-family: 'Arial', sans-serif;
		background-color: #1a1a1a;
		color: #ffffff;
		display: flex;
		justify-content: center;
		align-items: center;
		user-select: none;
	}
	h1 {font-size: 2.5rem;}
	.board {
		display: grid;
		grid-template-columns: repeat(3, 1fr);
		gap: 10px;
		margin: 1rem 0 1rem 0;
		position: relative;
	}
	.subBoard {
		display: grid;
		grid-template-columns: repeat(3, 1fr);
		gap: 2px;
		background-color: #333;
		padding: 5px;
		border-radius: 5px;
		position: relative;
	}
	.cell {
		width: 40px;
		height: 40px;
		background-color: #4a4a4a;
		display: flex;
		justify-content: center;
		align-items: center;
		font-size: 1.5rem;
		cursor: pointer;
		transition: background-color 0.3s;
	}
	.cell:hover {background-color: #555;}
	.winner {
		position: absolute;
		background-color: rgba(0, 0, 0, 0.8);
		color: #fff;
		font-size: 2rem;
		display: flex;
		justify-content: center;
		align-items: center;
		width: 100%;
		height: 100%;
		top: 0;
		left: 0;
	}
	.controls {display: flex; justify-content: center; gap: 10px; margin-top: 1rem;}
	button, select {
		padding: 0.5rem 1rem;
		font-size: 1rem;
		background-color: #4a4a4a;
		color: #ffffff;
		border: none;
		border-radius: 5px;
		cursor: pointer;
		transition: background-color 0.3s;
	}
	button:hover, select:hover {background-color: #555;}
	.activeBoard {box-shadow: 0 0 10px 5px #ffff00;}
	.activeCell {box-shadow: inset 0 0 0px 2px #ffff00;}
	.gameContainer {display: flex; flex-direction: row; align-items: center; gap: 20px; justify-content: center;}
	.numberSelector {display: none; flex-direction: column; gap: 15px; min-width: 60px;}
	.numberColumn {display: flex; flex-direction: column; gap: 10px; align-items: center;}
	.playerLabel {font-size: 0.9rem; margin-bottom: 5px; text-align: center;}
	.numberBtn {
		width: 50px;
		height: 50px;
		font-size: 1.5rem;
		background-color: #4a4a4a;
		color: #ffffff;
		border: 2px solid #666;
		border-radius: 5px;
		cursor: pointer;
		transition: all 0.3s;
	}
	.numberBtn:hover {background-color: #555;}
	.numberBtn.selected {background-color: #666; border-color: #ffff00; box-shadow: 0 0 10px 2px #ffff00;}
	@media (max-width: 500px) {
		body {overflow-y: auto; height: auto;}
		h1 {font-size: 1.5rem;}
		.gameContainer {gap: 0px; flex-direction: column;}
		.playerLabel {display: none;}
		.numberColumn {flex-direction: row; gap: 5px;}
		.numberBtn {width: 35px; height: 35px; font-size: 1.2rem;}
		.cell {width: 8vw; height: 8vw; font-size: 1.2rem;}
		.board {gap: 5px;}
		.subBoard {gap: 1px; padding: 3px;}
		.winner {font-size: 1.5rem;}
		.controls {flex-wrap: wrap; gap: 5px;}	
		button, select {padding: 0.4rem 0.8rem; font-size: 0.9rem;}
	}
</style>
<body>
	<div style="text-align: center;">
	<h1>Ultimate Tic-Tac-Toe</h1>
	<div class="gameContainer">
		<div id="xNumberSelector" class="numberSelector">
			<div class="numberColumn">
				<div class="playerLabel">Player X<br>(Evens)</div>
				<button class="numberBtn" onclick="selectNumber(0, 'X')">0</button>
				<button class="numberBtn" onclick="selectNumber(2, 'X')">2</button>
				<button class="numberBtn" onclick="selectNumber(4, 'X')">4</button>
				<button class="numberBtn" onclick="selectNumber(6, 'X')">6</button>
				<button class="numberBtn" onclick="selectNumber(8, 'X')">8</button>
			</div>
		</div>
		<div id="game" class="board"></div>
		<div id="oNumberSelector" class="numberSelector">
			<div class="numberColumn">
				<div class="playerLabel">Player O<br>(Odds)</div>
				<button class="numberBtn" onclick="selectNumber(1, 'O')">1</button>
				<button class="numberBtn" onclick="selectNumber(3, 'O')">3</button>
				<button class="numberBtn" onclick="selectNumber(5, 'O')">5</button>
				<button class="numberBtn" onclick="selectNumber(7, 'O')">7</button>
				<button class="numberBtn" onclick="selectNumber(9, 'O')">9</button>
			</div>
		</div>
	</div>
	<div class="controls" style="flex-direction: column; gap: 0.5rem;">
		<div>
			Player X: <select id="playerX">
				<option value="Human">Human</option>
				<option value="Easy">Easy</option>
				<option value="Medium">Medium</option>
				<option value="Hard">Hard</option>
				<option value="Impossible">Impossible</option>
			</select>
		</div><div>
			Player O: <select id="playerO">
				<option value="Human">Human</option>
				<option value="Easy">Easy</option>
				<option value="Medium">Medium</option>
				<option value="Hard">Hard</option>
				<option value="Impossible">Impossible</option>
			</select>
		</div>
		<div>
			Mode: <select id="gameMode" onchange="updateGameMode();">
				<option value="Normal">Normal</option>
				<option value="Limited" selected>Limited</option>
				<option value="Sudoku">Sudoku</option>
			</select>
			<button onclick="resetGame()">Reset</button>
		</div>
	</div>
	</div>
</body>

<script>
	let gameArr = [], player = 'X', currentBoard = 0, gameOver = false;
	let lines = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 4, 7], [2, 5, 8], [3, 6, 9], [1, 5, 9], [3, 5, 7]];
	let selectedNumber = null;
	let sudokuNumbers = {};

	function createBoard() {
		game.innerHTML = '';
		for (let i = 1; i <= 9; i++) {
			let subBoard = document.createElement('div');
			subBoard.className = 'subBoard';
			subBoard.id = `board-${i}`;
			for (let j = 1; j <= 9; j++) {
				let cell = document.createElement('div');
				cell.className = 'cell';
				cell.id = `${i}-${j}`;
				cell.onclick = () => makeMove(i, j);
				subBoard.appendChild(cell);
			}
			game.appendChild(subBoard);
		}
		updateActiveBoard();
	}

	function updateGameMode() {
		let display = gameMode.value === 'Sudoku' ? 'flex' : 'none';
		xNumberSelector.style.display = oNumberSelector.style.display = display;
	}

	function selectNumber(num, playerType) {
		if (gameMode.value !== 'Sudoku' || gameOver || playerType !== player) return;
		document.querySelectorAll('.numberBtn').forEach(btn => btn.classList.remove('selected'));
		selectedNumber = num;
		event.target.classList.add('selected');
		highlightValidCells();
	}

	function highlightValidCells() {
		document.querySelectorAll('.cell').forEach(cell => {cell.classList.remove('activeCell');});
		if (selectedNumber === null) return;
		for (let board = 1; board <= 9; board++) {
			if (typeof gameArr[board] !== 'object') continue;
			let validBoard = currentBoard === 0 || currentBoard === board || 
				(Array.isArray(currentBoard) && currentBoard.includes(board));
			if (!validBoard && currentBoard !== 0) continue;
			for (let cell = 1; cell <= 9; cell++) {
				if (gameArr[board][cell] === null && isValidSudokuMove(board, cell, selectedNumber)) {
					window[`${board}-${cell}`].classList.add('activeCell');
				}
			}
		}
	}

	function isValidSudokuMove(board, cell, number) {
		for (let c = 1; c <= 9; c++) {
			if (sudokuNumbers[`${board}-${c}`] === number) return false;
		}
		let boardRow = Math.floor((board - 1) / 3);
		let boardCol = (board - 1) % 3;
		let cellRow = Math.floor((cell - 1) / 3);
		let cellCol = (cell - 1) % 3;
		let globalRow = boardRow * 3 + cellRow;
		let globalCol = boardCol * 3 + cellCol;
		for (let col = 0; col < 9; col++) {
			let checkBoard = Math.floor(globalRow / 3) * 3 + Math.floor(col / 3) + 1;
			let checkCell = (globalRow % 3) * 3 + (col % 3) + 1;
			if (sudokuNumbers[`${checkBoard}-${checkCell}`] === number) {
				return false;
			}
		}
		for (let row = 0; row < 9; row++) {
			let checkBoard = Math.floor(row / 3) * 3 + Math.floor(globalCol / 3) + 1;
			let checkCell = (row % 3) * 3 + (globalCol % 3) + 1;
			if (sudokuNumbers[`${checkBoard}-${checkCell}`] === number) {
				return false;
			}
		}
		return true;
	}

	function resetGame() {
		gameArr = Array(10).fill().map(() => Array(10).fill(null));
		player = 'X';
		currentBoard = 0;
		gameOver = false;
		selectedNumber = null;
		sudokuNumbers = {};
		document.querySelectorAll('.numberBtn').forEach(btn => btn.classList.remove('selected'));
		createBoard();
		updateGameMode();
		if (playerX.value !== 'Human' && !gameOver) setTimeout(() => cpuMove(playerX.value), 250);
	}

	function makeMove(board, cell, isCPU = false) {
		let validBoard = currentBoard === 0 || currentBoard === board || (Array.isArray(currentBoard) && currentBoard.includes(board));
		if (gameOver || !validBoard || gameArr[board][cell] !== null || typeof gameArr[board] === 'string') return;
		if (!isCPU && (player === 'X' ? playerX.value : playerO.value) !== 'Human') return;
		if (gameMode.value === 'Sudoku') {
			if (!isCPU && selectedNumber === null) return;
			let numberToPlace = isCPU ? selectedNumber : selectedNumber;
			if (!isValidSudokuMove(board, cell, numberToPlace)) return;
			sudokuNumbers[`${board}-${cell}`] = numberToPlace;
			gameArr[board][cell] = player;
			window[`${board}-${cell}`].textContent = numberToPlace;
		}
		else {
			gameArr[board][cell] = player;
			window[`${board}-${cell}`].textContent = player;
		}
		if (checkWin(gameArr[board], player)) {
			gameArr[board] = player;
			addWinnerOverlay(`board-${board}`, player);
		}
		else if (gameArr[board].slice(1).every(cell => cell !== null)) {
			gameArr[board] = 'D';
			addWinnerOverlay(`board-${board}`, 'Draw');
		}
		if (checkWin(gameArr, player)) {
			addWinnerOverlay('game', `Player ${player} wins!`);
			gameOver = true;
			return;
		}
		else if (gameArr.slice(1).every(board => typeof board !== 'object')) {
			addWinnerOverlay('game', 'The game is a draw!');
			gameOver = true;
			return;
		}

		player = player === 'X' ? 'O' : 'X';
		selectedNumber = null;
		document.querySelectorAll('.numberBtn').forEach(btn => btn.classList.remove('selected'));
		
		if (gameMode.value === 'Limited') {
			let availableBoards = [1, 2, 3, 4, 5, 6, 7, 8, 9].filter(b => typeof gameArr[b] === 'object');
			if (typeof gameArr[cell] === 'object') {
				let rand = Math.random(), otherBoards = availableBoards.filter(b => b !== cell);
				if (rand < 0.05) currentBoard = 0;
				else if (rand < 0.4) currentBoard = cell;
				else if (rand < 0.60 && otherBoards.length > 0) currentBoard = [cell, otherBoards[Math.floor(Math.random() * otherBoards.length)]];
				else if (otherBoards.length > 1) {
					let shuffled = otherBoards.sort(() => Math.random() - 0.5);
					currentBoard = [cell, shuffled[0], shuffled[1]];
				}
				else currentBoard = otherBoards.length > 0 ? [cell, otherBoards[0]] : cell;
			} 
			else currentBoard = 0;
		} 
		else currentBoard = 0;
		updateActiveBoard();
		let nextPlayerType = player === 'X' ? playerX.value : playerO.value;
		if (nextPlayerType !== 'Human' && !gameOver) setTimeout(() => cpuMove(nextPlayerType), 250);
	}

	function addWinnerOverlay(elementId, text) {
		window[elementId].innerHTML += `<div class="winner">${text}</div>`;
	}

	function updateActiveBoard() {
		document.querySelectorAll('.subBoard').forEach(board => {board.classList.remove('activeBoard');});
		document.querySelectorAll('.cell').forEach(cell => {cell.classList.remove('activeBoard', 'activeCell');});
		if (gameMode.value === 'Sudoku') {
			if (selectedNumber !== null) highlightValidCells();
			return;
		}
		if (gameMode.value === 'Limited') {
			document.querySelectorAll('.subBoard').forEach(board => {
				let boardId = parseInt(board.id.split('-')[1]);
				let isActive = typeof gameArr[boardId] === 'object' && (currentBoard === 0 || currentBoard === boardId || (Array.isArray(currentBoard) && currentBoard.includes(boardId)));
				board.classList.toggle('activeBoard', isActive);
			});
		}
	}

	function checkWin(arr, playerToCheck) {
		return lines.some(line => line.every(cell => arr[cell] === playerToCheck));
	}

	function cpuMove(difficulty) {
		if (gameOver) return;
		let move;
		if (difficulty == 'Easy') move = easyMove();
		else if (difficulty == 'Medium') move = Math.random() < 0.5 ? hardMove() : easyMove();
		else if (difficulty == 'Hard') move = hardMove();
		else move = impossibleMove();
		if (move && !gameOver) makeMove(move.board, move.cell, true);
	}

	function getAvailableBoards(gameArr, targetBoard = currentBoard) {
		if (Array.isArray(targetBoard)) return targetBoard.filter(b => typeof gameArr[b] === 'object');
		return targetBoard !== 0 && typeof gameArr[targetBoard] === 'object' 
			? [targetBoard] : [1, 2, 3, 4, 5, 6, 7, 8, 9].filter(b => typeof gameArr[b] === 'object');
	}

	function getAvailableCells(gameArr, board) {
		if (gameMode.value === 'Sudoku') {
			let cells = [];
			for (let cell = 1; cell <= 9; cell++) {
				if (gameArr[board][cell] === null) cells.push(cell);
			}
			return cells;
		}
		return gameArr[board].reduce((acc, cell, index) => (index !== 0 && cell === null && acc.push(index), acc), []);
	}

	function easyMove() {
		if (gameOver) return null;
		let availableBoards = getAvailableBoards(gameArr);
		if (availableBoards.length === 0) return null;
		let board = availableBoards[Math.floor(Math.random() * availableBoards.length)];
		let availableCells = getAvailableCells(gameArr, board);
		if (availableCells.length === 0) return null;
		if (gameMode.value === 'Sudoku') {
			let numbers = player === 'X' ? [0, 2, 4, 6, 8] : [1, 3, 5, 7, 9];
			let attempts = 0;
			while (attempts < 10000) {
				let cell = availableCells[Math.floor(Math.random() * availableCells.length)];
				let number = numbers[Math.floor(Math.random() * numbers.length)];
				if (isValidSudokuMove(board, cell, number)) {
					selectedNumber = number;
					return { board, cell };
				}
				attempts++;
			}
		}
		return { board, cell: availableCells[Math.floor(Math.random() * availableCells.length)] };
	}

	function hardMove() {
		if (gameMode.value === 'Sudoku') {
			let availableBoards = getAvailableBoards(gameArr);
			let numbers = player === 'X' ? [0, 2, 4, 6, 8] : [1, 3, 5, 7, 9];
			for (let board of availableBoards) {
				for (let cell of getAvailableCells(gameArr, board)) {
					for (let number of numbers) {
						if (isValidSudokuMove(board, cell, number)) {
							let tempArr = [...gameArr[board]];
							tempArr[cell] = player;
							if (checkWin(tempArr, player)) {
								selectedNumber = number;
								return { board, cell };
							}
						}
					}
				}
			}
			let opponentPlayer = player === 'X' ? 'O' : 'X';
			let opponentNumbers = player === 'X' ? [1, 3, 5, 7, 9] : [0, 2, 4, 6, 8];
			for (let board of availableBoards) {
				for (let cell of getAvailableCells(gameArr, board)) {
					for (let oppNum of opponentNumbers) {
						if (isValidSudokuMove(board, cell, oppNum)) {
							let tempArr = [...gameArr[board]];
							tempArr[cell] = opponentPlayer;
							if (checkWin(tempArr, opponentPlayer)) {
								for (let number of numbers) {
									if (isValidSudokuMove(board, cell, number)) {
										selectedNumber = number;
										return { board, cell };
									}
								}
								break;
							}
						}
					}
				}
			}
			let preferredBoards = [5, 1, 3, 7, 9, 2, 4, 6, 8].filter(b => availableBoards.includes(b));
			let preferredCells = [5, 1, 3, 7, 9, 2, 4, 6, 8];
			for (let board of preferredBoards) {
				for (let cell of preferredCells) {
					if (getAvailableCells(gameArr, board).includes(cell)) {
						for (let number of numbers) {
							if (isValidSudokuMove(board, cell, number)) {
								selectedNumber = number;
								return { board, cell };
							}
						}
					}
				}
			}
		}
		let availableBoards = getAvailableBoards(gameArr);
		for (let board of availableBoards) {
			for (let cell of getAvailableCells(gameArr, board)) {
				gameArr[board][cell] = 'O';
				if (checkWin(gameArr[board], 'O')) {
					gameArr[board][cell] = null;
					return { board, cell };
				}
				gameArr[board][cell] = null;
			}
		}
		for (let board of availableBoards) {
			for (let cell of getAvailableCells(gameArr, board)) {
				gameArr[board][cell] = 'X';
				if (checkWin(gameArr[board], 'X')) {
					gameArr[board][cell] = null;
					return { board, cell };
				}
				gameArr[board][cell] = null;
			}
		}
		let goodBoards = availableBoards.filter(board => {
			let availableCells = getAvailableCells(gameArr, board);
			if (availableCells.length <= 2) {
				let xCount = 0, oCount = 0;
				for (let c = 1; c <= 9; c++) {
					if (gameArr[board][c] === 'X') xCount++;
					else if (gameArr[board][c] === 'O') oCount++;
				}
				if (Math.abs(xCount - oCount) <= 1) return false;
			}
			let opponentWinMoves = 0;
			for (let cell of availableCells) {
				gameArr[board][cell] = 'X';
				if (checkWin(gameArr[board], 'X')) opponentWinMoves++;
				gameArr[board][cell] = null;
			}
			return opponentWinMoves < 2;
		});
		let boardsToUse = goodBoards.length > 0 ? goodBoards : availableBoards;
		let preferredBoards = [5, 1, 3, 7, 9, 2, 4, 6, 8].filter(b => boardsToUse.includes(b));
		for (let board of preferredBoards) {
			let preferredCells = [5, 1, 3, 7, 9, 2, 4, 6, 8].filter(c => getAvailableCells(gameArr, board).includes(c));
			if (preferredCells.length > 0) return { board, cell: preferredCells[0] };
		}
		if (boardsToUse.length > 0) {
			let board = boardsToUse[0];
			let availableCells = getAvailableCells(gameArr, board);
			if (availableCells.length > 0) return {board, cell: availableCells[0]};
		}
	}
	
	function impossibleMove() {
		if (gameMode.value === 'Sudoku') {
			let availableBoards = getAvailableBoards(gameArr);
			let numbers = player === 'X' ? [0, 2, 4, 6, 8] : [1, 3, 5, 7, 9];
			let bestMove = null;
			let bestScore = -Infinity;
			for (let board of availableBoards) {
				for (let cell of getAvailableCells(gameArr, board)) {
					for (let number of numbers) {
						if (isValidSudokuMove(board, cell, number)) {
							let score = scoreSudokuMove(board, cell, number);
							if (score > bestScore) {
								bestScore = score;
								bestMove = { board, cell, number };
							}
						}
					}
				}
			}
			if (bestMove) {
				selectedNumber = bestMove.number;
				return { board: bestMove.board, cell: bestMove.cell };
			}
			return null;
		}
		
		let availableBoards = getAvailableBoards(gameArr), bestMove = null, bestScore = -Infinity;
		for (let board of availableBoards) {
			for (let cell of getAvailableCells(gameArr, board)) {
				let score = scoreMove(board, cell, gameArr);
				if (score > bestScore) {
					bestScore = score;
					bestMove = { board, cell };
				}
			}
		}
		return bestMove;
	}
	function scoreSudokuMove(board, cell, number) {
		let score = 0;
		let tempArr = gameArr.map(b => typeof b === 'object' ? [...b] : b);
		tempArr[board][cell] = player;
		if (checkWin(tempArr[board], player)) {
			score += 1000;
			tempArr[board] = player;
			if (checkWin(tempArr, player)) score += 5000;
		}
		let opponentPlayer = player === 'X' ? 'O' : 'X';
		for (let c = 1; c <= 9; c++) {
			if (gameArr[board][c] === null && c !== cell) {
				let testBoard = [...gameArr[board]];
				testBoard[c] = opponentPlayer;
				if (checkWin(testBoard, opponentPlayer)) score += 500;
			}
		}
		score += [0, 3, 1, 3, 1, 4, 3, 1, 3, 1][cell] * 5 + [0, 4, 2, 2, 2, 5, 2, 2, 2, 4][board] * 10;
		let remainingMoves = 0;
		for (let b = 1; b <= 9; b++) {
			if (typeof gameArr[b] !== 'object') continue;
			for (let c = 1; c <= 9; c++) {
				if (gameArr[b][c] === null && !(b === board && c === cell)) {
					let tempSudokuNumbers = { ...sudokuNumbers };
					tempSudokuNumbers[`${b}-${c}`] = number;
					if (isValidSudokuMoveWithTemp(b, c, number, tempSudokuNumbers)) remainingMoves++;
				}
			}
		}
		return score + remainingMoves * 2;
	}
	
	function isValidSudokuMoveWithTemp(board, cell, number, tempSudokuNumbers) {
		for (let c = 1; c <= 9; c++) {
			if (tempSudokuNumbers[`${board}-${c}`] === number) return false;
		}
		let boardRow = Math.floor((board - 1) / 3);
		let boardCol = (board - 1) % 3;
		let cellRow = Math.floor((cell - 1) / 3);
		let cellCol = (cell - 1) % 3;
		let globalRow = boardRow * 3 + cellRow;
		let globalCol = boardCol * 3 + cellCol;
		for (let col = 0; col < 9; col++) {
			let checkBoard = Math.floor(globalRow / 3) * 3 + Math.floor(col / 3) + 1;
			let checkCell = (globalRow % 3) * 3 + (col % 3) + 1;
			if (tempSudokuNumbers[`${checkBoard}-${checkCell}`] === number) return false;
		}
		for (let row = 0; row < 9; row++) {
			let checkBoard = Math.floor(row / 3) * 3 + Math.floor(globalCol / 3) + 1;
			let checkCell = (row % 3) * 3 + (globalCol % 3) + 1;
			if (tempSudokuNumbers[`${checkBoard}-${checkCell}`] === number) return false;
		}
		return true;
	}

	function scoreMove(board, cell, gameArr) {
		let score = 0;
		let tempBoard = [...gameArr[board]];
		tempBoard[cell] = 'O';
		if (checkWin(tempBoard, 'O')) score += 1000;
		tempBoard[cell] = 'X';
		if (checkWin(tempBoard, 'X')) score += 500;
		tempBoard[cell] = 'O';
		let tempGame = gameArr.map(b => typeof b === 'object' ? [...b] : b);
		if (checkWin(tempBoard, 'O')) {
			tempGame[board] = 'O';
			if (checkWin(tempGame, 'O')) score += 5000;
		}
		for (let b = 1; b <= 9; b++) {
			if (typeof gameArr[b] === 'object') {
				for (let c = 1; c <= 9; c++) {
					if (gameArr[b][c] === null) {
						let testBoard = [...gameArr[b]];
						testBoard[c] = 'X';
						if (checkWin(testBoard, 'X')) {
							tempGame = gameArr.map(bb => typeof bb === 'object' ? [...bb] : bb);
							tempGame[b] = 'X';
							if (checkWin(tempGame, 'X')) score += (b === board && c === cell) ? 3000 : 0;
						}
					}
				}
			}
		}
		if (typeof gameArr[board] !== 'string') score += [0, 4, 2, 2, 2, 5, 2, 2, 2, 4][board] * 10;
		score += [0, 3, 1, 3, 1, 4, 3, 1, 3, 1][cell] * 5;
		if (gameMode.value === 'Limited' && typeof gameArr[cell] === 'object') {
			let opponentWinMoves = 0;
			for (let c = 1; c <= 9; c++) {
				if (gameArr[cell][c] === null) {
					let testBoard = [...gameArr[cell]];
					testBoard[c] = 'X';
					if (checkWin(testBoard, 'X')) opponentWinMoves++;
				}
			}
			score -= opponentWinMoves * 50;
		}
		return score;
	}

	window.onload = resetGame();
</script>
</html>